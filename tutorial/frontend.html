<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Building custom frontend - Intuicio - Modular scripting platform for Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Intuicio - Modular scripting platform for Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="building-custom-frontend"><a class="header" href="#building-custom-frontend">Building custom frontend</a></h1>
<p>This is gonna be basically a pretty much stripped down version of <code>assembler</code> frontend just to get intuition on creating frontends. For more advanced examples of frontends please take a look at frontends already made, located in <code>frontends</code> folder on repository.</p>
<hr />
<p>Let's start with defining goals for this frontend to achieve:</p>
<ul>
<li>scripts operate only on <code>i32</code> values.</li>
<li>scripts will have two operations:
<ul>
<li>push value on stack.</li>
<li>call functions that takes values from stack, performs operations on them and push results back on stack.</li>
</ul>
</li>
<li>syntax of this language has to be simple, so that:
<ul>
<li>each line is an operation or comment.</li>
<li>we put operations in reverse order so it is easier to read script as a hierarchy of function calls with its arguments indented and in ascending order.</li>
</ul>
</li>
</ul>
<p>Frontend syntax:</p>
<pre><code class="language-text">call lib div
    call lib mul
        push 3
        call lib sub
            call lib add
                push 40
                push 2
            push 10
    push 2
</code></pre>
<hr />
<p>So now let's create new project and add Intuicio dependencies:</p>
<pre><code class="language-toml">[dependencies]
intuicio-data = "*"
intuicio-core = "*"
intuicio-derive = "*"
intuicio-backend-vm = "*"
</code></pre>
<p>Then create <code>frontend.rs</code> file, where we will heep all frontend-related code, and first import these dependencies:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use intuicio_core::prelude::*;
use std::{error::Error, str::FromStr};
<span class="boring">}</span></code></pre></pre>
<p><code>intuicio_core</code> holds types related to script information, we use <code>Error</code> trait for errors propagation and <code>FromStr</code> for parsing.</p>
<hr />
<p>The most important thing to make is custom Intuiocio expression:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub enum CustomExpression {
    Literal(i32),
}

impl ScriptExpression for CustomExpression {
    fn evaluate(&amp;self, context: &amp;mut Context, _: &amp;Registry) {
        match self {
            Self::Literal(value) =&gt; {
                context.stack().push(*value);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Expressions allow to extend available operations set of Intuicio scripts to enable features specific to given frontend - here we just allow to push <code>i32</code> literals onto stack.</p>
<hr />
<p>Now we will define intermediate script types for our Custom scripting language:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type CustomScript = Vec&lt;CustomOperation&gt;;

pub enum CustomOperation {
    Comment { content: String },
    Push { value: i32 },
    Call { name: String, module_name: String },
}
<span class="boring">}</span></code></pre></pre>
<p>Next we need to implement parsing of operations from string lines to intermediate script data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FromStr for CustomOperation {
    type Err = CustomOperationError;

    fn from_str(line: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        let line = line.trim();
        if line.is_empty() {
            return Ok(Self::Comment {
                content: "".to_owned(),
            });
        }
        if line.starts_with("#") {
            return Ok(Self::Comment {
                content: line.to_owned(),
            });
        }
        let mut tokens = line.split_ascii_whitespace();
        match tokens.next() {
            Some("push") =&gt; {
                let value = tokens.next().unwrap().parse::&lt;i32&gt;().unwrap();
                Ok(Self::Push { value })
            }
            Some("call") =&gt; {
                let module_name = tokens.next().unwrap().to_owned();
                let name = tokens.next().unwrap().to_owned();
                Ok(Self::Call { name, module_name })
            }
            _ =&gt; Err(CustomOperationError {
                operation: line.to_owned(),
            }),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Also don't forget to implement our parsing error type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct CustomOperationError {
    pub operation: String,
}

impl std::fmt::Display for CustomOperationError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, "Unsupported operation: `{}`", self.operation)
    }
}

impl Error for CustomOperationError {}
<span class="boring">}</span></code></pre></pre>
<hr />
<p>After that we need to implement script compilation from intermediate to Intuicio scripts data, so scripts will be understood by Intuicio backend:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl CustomOperation {
    pub fn compile_operation(&amp;self) -&gt; Option&lt;ScriptOperation&lt;'static, CustomExpression&gt;&gt; {
        match self {
            Self::Comment { .. } =&gt; None,
            Self::Push { value } =&gt; Some(ScriptOperation::Expression {
                expression: CustomExpression::Literal(*value),
            }),
            Self::Call { name, module_name } =&gt; Some(ScriptOperation::CallFunction {
                query: FunctionQuery {
                    name: Some(name.to_owned().into()),
                    module_name: Some(module_name.to_owned().into()),
                    ..Default::default()
                },
            }),
        }
    }

    pub fn compile_script(
        operations: &amp;[CustomOperation],
    ) -&gt; ScriptHandle&lt;'static, CustomExpression&gt; {
        operations
            .iter()
            .rev()
            .filter_map(|operation| operation.compile_operation())
            .collect::&lt;Vec&lt;_&gt;&gt;()
            .into()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In <code>compile_script</code> method we iterate over operations in reverse order, because human-readable side of the scripts expects function call and then its parameters, while Intuicio scripts expect computer-readable order of arguments first, then function call.</p>
<hr />
<p>Finally we create scripts content parser so it can be used to parse byte strings into intermediate type scripts:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CustomContentParser;

impl BytesContentParser&lt;CustomScript&gt; for CustomContentParser {
    fn parse(&amp;self, bytes: Vec&lt;u8&gt;) -&gt; Result&lt;CustomScript, Box&lt;dyn Error&gt;&gt; {
        Ok(String::from_utf8(bytes)?
            .lines()
            .filter(|line| !line.is_empty())
            .map(|line| CustomOperation::from_str(line))
            .collect::&lt;Result&lt;CustomScript, _&gt;&gt;()?)
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<p>Now let's create <code>main.rs</code> file, where we will test this frontend, first import dependencies:</p>
<pre><pre class="playground"><code class="language-rust">mod frontend;
mod library;

use crate::frontend::*;
use intuicio_backend_vm::prelude::*;
use intuicio_core::prelude::*;

fn main() {
    // next steps go here.
}</code></pre></pre>
<p>Then parse and compile some script:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let script = b"
call lib div
    call lib mul
        push 3
        call lib sub
            call lib add
                push 40
                push 2
            push 10
    push 2
";
let script = CustomContentParser.parse(script.to_vec()).unwrap();
let script = CustomOperation::compile_script(&amp;script);
<span class="boring">}</span></code></pre></pre>
<p>Next, create and setup registry:</p>
<pre><pre class="playground"><code class="language-rust">let mut registry = Registry::default().with_basic_types();
crate::library::install(&amp;mut registry);
registry.add_function(Function::new(
    function_signature! {
        registry =&gt; mod main fn main() -&gt; (result: i32)
    },
    VmScope::&lt;CustomExpression&gt;::generate_function_body(script, None)
        .unwrap()
        .0,
));</code></pre></pre>
<p>As you can see, our scripts do not define functions, rather operations that belong to single one, so we create new main function and add it to the registry. We also use <code>VmScope</code> from VM backend to test this frontend in already existing VM backend, until we create dedicated backend ourselves.</p>
<p>Final thing to do is to create host and test frontend:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut host = Host::new(Context::new(10240, 10240), registry.into());
let (result,) = host
    .call_function::&lt;(i32,), _&gt;("main", "main", None)
    .unwrap()
    .run(());
assert_eq!(result, 48);
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../tutorial/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../tutorial/backend.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tutorial/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../tutorial/backend.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
