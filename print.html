<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Intuicio - Modular scripting platform for Rust</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="scripting-pipeline-explained.html"><strong aria-hidden="true">2.</strong> Scripting pipeline explained</a></li><li class="chapter-item expanded "><a href="anatomy-of-a-host.html"><strong aria-hidden="true">3.</strong> Anatomy of a Host</a></li><li class="chapter-item expanded "><a href="anatomy-of-a-script.html"><strong aria-hidden="true">4.</strong> Anatomy of a Script</a></li><li class="chapter-item expanded "><a href="tutorial/index.html"><strong aria-hidden="true">5.</strong> Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorial/frontend.html"><strong aria-hidden="true">5.1.</strong> Building custom frontend</a></li><li class="chapter-item expanded "><a href="tutorial/backend.html"><strong aria-hidden="true">5.2.</strong> Building custom backend</a></li><li class="chapter-item expanded "><a href="tutorial/runner.html"><strong aria-hidden="true">5.3.</strong> Building custom runner</a></li></ol></li><li class="chapter-item expanded "><a href="official-frontends/index.html"><strong aria-hidden="true">6.</strong> Official frontends</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="official-frontends/assembler/index.html"><strong aria-hidden="true">6.1.</strong> Assembler</a></li><li class="chapter-item expanded "><a href="official-frontends/serde/index.html"><strong aria-hidden="true">6.2.</strong> Serde</a></li><li class="chapter-item expanded "><a href="official-frontends/vault/index.html"><strong aria-hidden="true">6.3.</strong> Vault</a></li><li class="chapter-item expanded "><a href="official-frontends/simpleton/index.html"><strong aria-hidden="true">6.4.</strong> Simpleton</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="official-frontends/simpleton/language-reference.html"><strong aria-hidden="true">6.4.1.</strong> Language reference</a></li><li class="chapter-item expanded "><a href="official-frontends/simpleton/api-reference/index.html"><strong aria-hidden="true">6.4.2.</strong> API reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="official-frontends/simpleton/api-reference/reflect.html"><strong aria-hidden="true">6.4.2.1.</strong> Reflect</a></li><li class="chapter-item expanded "><a href="official-frontends/simpleton/api-reference/closure.html"><strong aria-hidden="true">6.4.2.2.</strong> Closure</a></li><li class="chapter-item expanded "><a href="official-frontends/simpleton/api-reference/debug.html"><strong aria-hidden="true">6.4.2.3.</strong> Debug</a></li><li class="chapter-item expanded "><a href="official-frontends/simpleton/api-reference/console.html"><strong aria-hidden="true">6.4.2.4.</strong> Console</a></li><li class="chapter-item expanded "><a href="official-frontends/simpleton/api-reference/math.html"><strong aria-hidden="true">6.4.2.5.</strong> Math</a></li><li class="chapter-item expanded "><a href="official-frontends/simpleton/api-reference/array.html"><strong aria-hidden="true">6.4.2.6.</strong> Array</a></li><li class="chapter-item expanded "><a href="official-frontends/simpleton/api-reference/map.html"><strong aria-hidden="true">6.4.2.7.</strong> Map</a></li><li class="chapter-item expanded "><a href="official-frontends/simpleton/api-reference/text.html"><strong aria-hidden="true">6.4.2.8.</strong> Text</a></li><li class="chapter-item expanded "><a href="official-frontends/simpleton/api-reference/bytes.html"><strong aria-hidden="true">6.4.2.9.</strong> Bytes</a></li><li class="chapter-item expanded "><a href="official-frontends/simpleton/api-reference/json.html"><strong aria-hidden="true">6.4.2.10.</strong> JSON</a></li><li class="chapter-item expanded "><a href="official-frontends/simpleton/api-reference/toml.html"><strong aria-hidden="true">6.4.2.11.</strong> TOML</a></li><li class="chapter-item expanded "><a href="official-frontends/simpleton/api-reference/iter.html"><strong aria-hidden="true">6.4.2.12.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="official-frontends/simpleton/api-reference/event.html"><strong aria-hidden="true">6.4.2.13.</strong> Event</a></li><li class="chapter-item expanded "><a href="official-frontends/simpleton/api-reference/promise.html"><strong aria-hidden="true">6.4.2.14.</strong> Promise</a></li><li class="chapter-item expanded "><a href="official-frontends/simpleton/api-reference/fs.html"><strong aria-hidden="true">6.4.2.15.</strong> File system</a></li><li class="chapter-item expanded "><a href="official-frontends/simpleton/api-reference/process.html"><strong aria-hidden="true">6.4.2.16.</strong> Process</a></li><li class="chapter-item expanded "><a href="official-frontends/simpleton/api-reference/net.html"><strong aria-hidden="true">6.4.2.17.</strong> Network</a></li><li class="chapter-item expanded "><a href="official-frontends/simpleton/api-reference/jobs.html"><strong aria-hidden="true">6.4.2.18.</strong> Jobs (multithreading)</a></li></ol></li></ol></li></ol></li><li class="chapter-item expanded "><a href="official-runners/index.html"><strong aria-hidden="true">7.</strong> Official runners</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="official-runners/simpleton/index.html"><strong aria-hidden="true">7.1.</strong> Simpleton</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="official-runners/simpleton/api-reference/index.html"><strong aria-hidden="true">7.1.1.</strong> API reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="official-runners/simpleton/api-reference/script.html"><strong aria-hidden="true">7.1.1.1.</strong> Script</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="official-runners/alchemyst/index.html"><strong aria-hidden="true">7.2.</strong> Alchemyst</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="official-runners/alchemyst/api-reference/index.html"><strong aria-hidden="true">7.2.1.</strong> API reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="official-runners/alchemyst/api-reference/color.html"><strong aria-hidden="true">7.2.1.1.</strong> Color</a></li><li class="chapter-item expanded "><a href="official-runners/alchemyst/api-reference/vec2.html"><strong aria-hidden="true">7.2.1.2.</strong> Vec2</a></li><li class="chapter-item expanded "><a href="official-runners/alchemyst/api-reference/image.html"><strong aria-hidden="true">7.2.1.3.</strong> Image</a></li><li class="chapter-item expanded "><a href="official-runners/alchemyst/api-reference/image-pipeline.html"><strong aria-hidden="true">7.2.1.4.</strong> Image Pipeline</a></li></ol></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Intuicio - Modular scripting platform for Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><strong>Project repository</strong>: <a href="https://github.com/PsichiX/Intuicio">github.com/PsichiX/Intuicio</a></p>
<p><img src="https://raster.shields.io/crates/v/intuicio-core.png" alt="crates-io version" /></p>
<h2 id="what-is-intuicio"><a class="header" href="#what-is-intuicio">What is Intuicio?</a></h2>
<p>In short words: Intuicio is a set of building blocks designed to build your own scripting solution in Rust.</p>
<p>Every complete scripting solution built on Intuicio is split into:</p>
<h2 id="script"><a class="header" href="#script">Script</a></h2>
<p>Scripts are all the information that defines a script in form of data.</p>
<p>It is an interface between frontends and backends to allow modularity and relatively universal way of communication between them.</p>
<p>Scripts are produced by frontends for backends to "run" them (more precisely to just use them, usually backends are used to execute scripts, but one can create something like a nativizer to transpile script into native code to run).</p>
<p>Scripts data is defined in <code>intuicio-core</code> crate, <code>script</code> module.</p>
<h2 id="frontend"><a class="header" href="#frontend">Frontend</a></h2>
<p>Frontends are used to convert some data into scripts data.</p>
<p>Usually when we talk about scripting frontend, we are talking about compilers/transpilers for example - in general frontends can parse text code file for particular scripting language and turn it into Intuicio scripts that will be later used by backends. This doesn't mean we are forced to parsing text code files - one can create a node-graph-like scripting language and frontend for converting that into scripts, or even turn images into scripts, only limit is imagination, all Intuicio needs is just scripts data, and how we get them doesn't really matter.</p>
<p>There are examples of few frontends in Intuicio repositiory <code>frontends</code> folder, these are:</p>
<ul>
<li><code>intuicio-frontend-assembler</code> - simple assembler-like language that has the closest representation to script data one can get.</li>
<li><code>intuicio-frontend-serde</code> - this one allows to represent scripts in any of the file formats that <code>serde</code> can support, for example JSON and YAML, or even LEXPR.</li>
<li><code>intuicio-frontend-vault</code> - an attempt to create strongly typed language written with LEXPR syntax.</li>
<li><code>intuicio-frontend-simpleton</code> - a full example of simple dynamically typed scripting language with rich standard library.</li>
</ul>
<h2 id="backend"><a class="header" href="#backend">Backend</a></h2>
<p>Backends are used to "run" scripts, or more specifically to use scripts produced by frontends in any way they want.</p>
<p>An obvious backend that anyone can think of is a Virtual Machine, already made as <code>intuicio-backend-vm</code> crate. This one grabs script data and executes it directly in <code>VmScope</code>s that are self-contained units that executes set of Intuicio script operations.</p>
<p>Another example of backend can be "nativizer" - nativizers are units that transpile scripts into native code, in this case Rust code. Nativizers are great way to speed up scripts execution, by removing the need for constructing and loading scripts at runtime, rather to just get native code that would do what scripts do, but without extra overhead. Although there is an <code>intuicio-backend-rust</code> crate that aims to do that, it is still incomplete, mostly non-functional until it gets proper definition, but experiments are being made and eventually Intuicio will have its own default nativizer.</p>
<h2 id="host"><a class="header" href="#host">Host</a></h2>
<p>Host is basically an application-space (native side) of scripting logic, where user creates libraries of native functions and structs to bind into <code>Registry</code>, which later can be called or accessed by script operations or other native side code within given <code>Context</code>, shared between scripting and native side and treated equally as same.</p>
<p>The goal here is to allow for seamless interoperability between scripting and native sides of program logic, not forcing users to focus all their effort onto one particular side, something that is quite unique for scripting solutions, and this design decision was borrowed from Unreal Engine where it proven to be at least quite useful.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scripting-pipeline-explained"><a class="header" href="#scripting-pipeline-explained">Scripting pipeline explained</a></h1>
<p>Here we will attempt to explain entire scripting pipeline using examples of building blocks already made.</p>
<h2 id="first-things-first"><a class="header" href="#first-things-first">First things first</a></h2>
<p>Now let's pick some building blocks. For backend we will use <code>intuicio-backend-vm</code>, and for frontend we will use <code>intuicio-frontend-assembler</code> (this may look quite unintuitive but it will allow us better explain how bindings work with scripts, so please bare with me for a little).</p>
<p>Create new Cargo project and add these dependencies:</p>
<pre><code class="language-toml">[dependencies]
intuicio-data = "*"
intuicio-core = "*"
intuicio-derive = "*"
intuicio-backend-vm = "*"
intuicio-frontend-assembler = "*"
</code></pre>
<p>Once we have created new project, now in <code>main.rs</code> import these:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use intuicio_backend_vm::prelude::*;
use intuicio_core::prelude::*;
use intuicio_derive::*;
use intuicio_frontend_assembler::*;
<span class="boring">}</span></code></pre></pre>
<hr />
<p>Now let's define a simple native function that our script will call:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[intuicio_function(module_name = "lib")]
fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
<span class="boring">}</span></code></pre></pre>
<p>We use procedural attribute macro that will generate and fill <code>Function</code> type with all the information about this function. We could also construct it by hand, or even with procedural macro like this to register its result into <code>Registry</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>registry.add_function(define_function! {
    registry =&gt; mod lib fn add(a: i32, b: i32) -&gt; (result: i32) {
        (a + b,)
    }
});
<span class="boring">}</span></code></pre></pre>
<p>But for the sake of simplicity, just stay with <code>intuicio_function</code> macro.</p>
<hr />
<p>Then in <code>main</code> function first thing we should create is <code>Registry</code> to store all definitions of structures and functions, both native and script side ones, we also add basic types to not have to add them manually, and register defined function into that registry:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut registry = Registry::default().with_basic_types();
registry.add_function(add::define_function());
<span class="boring">}</span></code></pre></pre>
<p>Like we have said before, registry should hold all the structures and functions information that scripts can interact with, and because Registry turns immutable once it gets into execution phase, better to do that from the get go - you won't be able to modify registry later.</p>
<hr />
<p>Next step is to load, parse, compile and install assembly script into registry:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut content_provider = FileContentProvider::new("iasm", AsmContentParser);
AsmPackage::new("./resources/main.iasm", &amp;mut content_provider)
    .unwrap()
    .compile()
    .install::&lt;VmScope&lt;AsmExpression&gt;&gt;(&amp;mut registry, None);
<span class="boring">}</span></code></pre></pre>
<p><code>FileContentProvider</code> allows to pull script content from file system, <code>AsmContentParser</code> parses assembly script content into <code>AsmPackage</code> (intermediate representation of assembly scripts), <code>VmScope</code> is a container for script operations compiled from <code>AsmPackage</code> and finally <code>AsmExpression</code> is a set of custom operations that assembly scripting language performs. Expressions are an essential part of Intuicio scripting, since bare bones script data has very limited, universal set of basic operations required to make scripts call functions and move data between stack and registers - expressions allow extending set of operations, in case of <code>AsmExpression</code> scripts can push literals into stack and drop and forget value from stack.</p>
<hr />
<p>Last step is to construct <code>Context</code> and put it with <code>Registry</code> into <code>Host</code> that will allow calling any function from the registry:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let context = Context::new(
    // stack bytes capacity.
    1024,
    // registers bytes capacity.
    1024,
    // heap page capacity.
    1024,
);
let mut host = Host::new(context, RegistryHandle::new(registry));
let (result,) = host
    .call_function::&lt;(i32,), _&gt;(
        // function name.
        "main",
        // module name.
        "test",
        // structure name if function belongs to one.
        None,
    )
    .unwrap()
    .run(());
assert_eq!(result, 42);
<span class="boring">}</span></code></pre></pre>
<hr />
<p>Now the only thing what's left is to create <code>./resources/main.iasm</code> file and fill it with script code:</p>
<pre><code>mod test {
    fn main() -&gt; (result: struct i32) {
        literal 40 i32;
        literal 2 i32;
        call mod lib fn add;
    }
}
</code></pre>
<p>We can see all this script is doing is pushing data on stack and calling a function - this will help us explain what is happening much easier.</p>
<h2 id="how-data-moves"><a class="header" href="#how-data-moves">How data moves</a></h2>
<p>Let's start with showing how our <code>add</code> function actually looks like to <code>Host</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(context: &amp;mut Context, registry: &amp;Registry) {
    let a = context.stack().pop::&lt;i32&gt;().unwrap();
    let b = context.stack().pop::&lt;i32&gt;().unwrap();
    let result = a + b;
    context.stack().push(result);
}
<span class="boring">}</span></code></pre></pre>
<p>Now from the example above we can see that execution starts from application-space when we tell <code>Host</code> to find <code>main</code> function of <code>test</code> module in host's registry, once is found, host passes its <code>Context</code> and <code>Registry</code> to function generated from script.</p>
<p>This is how <code>test::main</code> script function would look like to <code>Host</code> when converted to Rust:</p>
<pre><pre class="playground"><code class="language-rust">fn main(context: &amp;mut Context, registry: &amp;Registry) {
    context.stack().push(40_i32);
    context.stack().push(2_i32);
    registry
        .find_function(FunctionQuery {
            name: Some("add".into()),
            module_name: Some("lib".into()),
            ..Default::default()
        })
        .unwrap()
        .invoke(context, registry);
}</code></pre></pre>
<p>So both together simply reduce to:</p>
<pre><pre class="playground"><code class="language-rust">fn main(context: &amp;mut Context, registry: &amp;Registry) {
    context.stack().push(40_i32);
    context.stack().push(2_i32);
    add(context, registry);
}</code></pre></pre>
<p>And this is basically exactly how and why Intuicio doesn't care about which side (script or native) calls what side - both script and native sides are calling each other the same way, and <code>VmScope</code> is just a container for script operations in the middle of interactions to make script side look the same as native side to host - this opens quite interesting opportunity, if expression type matches, to use different frontends together in one application. You can think of it as something like <code>.NET</code> platform for Rust.</p>
<h1 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h1>
<p>To summarize, Intuicio is actually <strong><em>just</em></strong> an engine to move data from place to place via stack, it doesn't care what is the data, it doesn't specify limits on the types of data (other than data has to be owned), it also doesn't care what is the place this data moves to, all it does is moves the data and both script and native side tells it when to move what data - simple as that!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anatomy-of-a-host"><a class="header" href="#anatomy-of-a-host">Anatomy of a Host</a></h1>
<p><code>Host</code> is just a handy container for <code>Context</code> and <code>Registry</code> that simplifies calling functions registered in <code>Registry</code> within given <code>Context</code>.</p>
<h2 id="registry"><a class="header" href="#registry">Registry</a></h2>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<p><code>Registry</code> contains all structures and functions that both scripting and native side expose for both sides to interact with.</p>
<p>Here is an example of how to register functions both from native and script sides:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[intuicio_function(module_name = "lib")]
fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

let mut registry = Registry::default().with_basic_types();
registry.add_function(add::define_function());
let mut content_provider = FileContentProvider::new("iasm", AsmContentParser);
AsmPackage::new("main.iasm", &amp;mut content_provider)
    .unwrap()
    .compile()
    .install::&lt;VmScope&lt;AsmExpression&gt;&gt;(&amp;mut registry, None);
<span class="boring">}</span></code></pre></pre>
<p>Of course we don't actually require frontends to register script-side functions and structures, here is an example of how one could create raw scripted function, knowing the backend it's gonna use (<code>VmScope</code> here):</p>
<pre><pre class="playground"><code class="language-rust">registry.add_function(
    Function::new(
        function_signature! {
            registry =&gt; mod test fn main() -&gt; (result: i32)
        },
        VmScope::&lt;AsmExpression&gt;::generate_function_body(
            ScriptBuilder::&lt;AsmExpression&gt;::default()
                .literal(AsmExpression::Literal(AsmLiteral::I32(2)))
                .literal(AsmExpression::Literal(AsmLiteral::I32(40)))
                .call_function(FunctionQuery {
                    name: Some("add".into()),
                    module_name: Some("lib".into()),
                    ..Default::default()
                })
                .build(),
            &amp;registry,
            None,
        )
        .unwrap()
        .0,
    ),
);</code></pre></pre>
<p>And as we can see above, we can use completely different backends for each function we want to register, therefore in principle, one application can run multiple backends, not forcing user to use only one, which is yet another deliberate design decision to allow interoperability between different backends.</p>
<blockquote>
<p>Also remember that since Intuicio is all about moving data into and out of function calls, every function that we want to call, has to be always registered in the registry and registry cannot be modified when used in function calls!</p>
</blockquote>
<h3 id="queries"><a class="header" href="#queries">Queries</a></h3>
<p>If user wants to call function from registry, user has to find it first and to do that we use <code>FunctionQuery</code> that defines search parameters for registry to filter functions with:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (result,) = registry.find_function(FunctionQuery {
    name: Some("add".into()),
    module_name: Some("lib".into()),
    ..Default::default()
})
.expect("`lib::add` function not found!")
.call::&lt;(i32,), _&gt;(&amp;mut context, &amp;registry, (40_i32, 2_i32), true);
assert_eq!(result, 42);
<span class="boring">}</span></code></pre></pre>
<p>When we want to find and call registered function from within another native function, we should be able as long as native-side function has access to context and registry:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[intuicio_function(module_name = "script", use_context, use_registry)]
fn script_add(context: &amp;mut Context, registry: &amp;Registry, a: i32, b: i32) -&gt; i32 {
    context.stack().push(b);
    context.stack().push(a);
    registry.find_function(FunctionQuery {
        name: Some("add".into()),
        module_name: Some("lib".into()),
        ..Default::default()
    })
    .expect("`lib::add` function not found!")
    .invoke(context, registry);
    context.stack().pop::&lt;i32&gt;().expect("Expected to return `i32`!")
}
<span class="boring">}</span></code></pre></pre>
<p>Btw. in snippet above we perform function invoke instead of a call, and notice order of pushing values into stack - by design native functions expect to pop their arguments from first to last argument, and push its result in reverse order to match later function calls proper argument pop order. For convienience it is advised to perform function calls instead of invokes, because function calls keep proper stack push and pop order on their own.</p>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<p><code>Context</code> is a container that holds:</p>
<ul>
<li>
<p><strong>Stack</strong></p>
<p>Used to move data between function calls.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>context.stack().push(42_i32);
assert_eq!(context.stack().pop::&lt;i32&gt;().unwrap(), 42);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Registers</strong></p>
<p>Indexed data storage, the closest analogue for local function variables.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (stack, registers) = context.stack_and_registers();
let index = registers.push_register().unwrap();
stack.push(42_i32);
let mut register = registers.access_register(index).unwrap();;
registers.pop_to_register(&amp;mut register);
stack.push_from_register(&amp;mut register);
assert_eq!(stack.pop::&lt;i32&gt;().unwrap(), 42);
<span class="boring">}</span></code></pre></pre>
<p>Please remember that with registers, just like with stack, data can be only moved in and out of registers, registers operations does not copy/clone their data - this design choice was dictated by master rule of Intuicio: "data can only be moved", copy/clone is a special operation that given structure has to provide a dedicated function for it to push duplicated source data into stack, from which original data gets moved back to register and its clone stays on the stack - this is what for example <code>simpleton</code> frontend does when it has to copy <code>Reference</code> from local variable to stack for later use.</p>
</li>
<li>
<p><strong>Heap</strong></p>
<p>Used to store dynamically allocated data in case user wants to ensure that data lifetime to be bound to the context (die along with context death). To be honest, this is not widely used piece of context, since data stored in any of the other pieces of context has no requirement to come from context's heap, it works perfectly fine with data allocated purely on rust-side, although at some point there might be a scenario where having boxed data owned by context is beneficial, therefore it is exposed to the user.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut value = context.heap().alloc(0_i32);
*value.write().uwnrap() = 42;
assert_eq!(*value.read().unwrap(), 42);
<span class="boring">}</span></code></pre></pre>
<p>It's worth noting that memory allocated by heap box gets automatically returned to the heap once heap box drops, so there is no explicit heap box deallocation.</p>
</li>
<li>
<p><strong>Custom data</strong></p>
<p>Now this is the interesting bit, it is basically a hash map of <code>Box&lt;Any + Send + Sync&gt;</code> objects that does not fit to any of the other context pieces. It is useful for storing any meta information. For example <code>simpleton</code> frontend stores there its <code>HostProducer</code> that is used to construct new <code>Host</code> for any spawned <code>Jobs</code> worker thread, so each worker thread can execute closures passed into it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>context.set_custom("foo", 42_i32);
assert_eq!(*context.custom::&lt;i32&gt;().unwrap(), 42);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anatomy-of-a-script"><a class="header" href="#anatomy-of-a-script">Anatomy of a Script</a></h1>
<p>Entire <code>Script</code> structure is split into package, modules, functions/structures and at it's core: operations.</p>
<p>Example:</p>
<ul>
<li>Package:
<ul>
<li>module: <code>test</code>
<ul>
<li>struct: <code>Foo</code>
<ul>
<li>field: <code>a</code>: <code>bool</code></li>
</ul>
</li>
<li>function: <code>main</code>
<ul>
<li>output: <code>result</code>: <code>i32</code></li>
<li>operations:
<ul>
<li>literal: <code>40</code>: <code>i32</code></li>
<li>literal: <code>2</code>: <code>i32</code></li>
<li>call function: <code>lib::add</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="operations"><a class="header" href="#operations">Operations</a></h2>
<p>Intuicio scripts by default have a very limited set of operations, because of being an universal interface between frontends and backends, these operations have to be the lowest denominator across most possible frontend and backend designs, therefore operations it haves are:</p>
<ul>
<li>
<p><strong>Expression</strong></p>
<p>This is an additional set of possible operations defined by frontends. It accepts types that implement <code>ScriptExpression</code> that allows to evaluate additional operation using only context and registry.
Common example of script expression is pushing literals onto stack - stack manipulation is not part of the script operations set, because Intuicio is completely generic over the data it moves, and specific frontends most likely do have very specific assumptions about the data they allow to use, so it's better to leave this kind of operations to be provided by them.</p>
<p>Example of custom script expression:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum CustomExpression {
    Literal(i32),
    StackDrop,
}

impl ScriptExpression for CustomExpression {
    fn evaluate(&amp;self, context: &amp;mut Context, _: &amp;Registry) {
        match self {
            Self::Literal(value) =&gt; {
                context.stack().push(*value);
            }
            Self::StackDrop =&gt; {
                context.stack().drop();
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Define register</strong></p>
<p>Allocates space for new register of given type defined by <code>StructQuery</code>. Remember to always define register before it gets used! Registers gets removed when scope where they were defined gets dropped.</p>
</li>
<li>
<p><strong>Drop register</strong></p>
<p>Drops data behind given register.</p>
</li>
<li>
<p><strong>Push from register</strong></p>
<p>Takes data from given register and pushes it onto stack.</p>
</li>
<li>
<p><strong>Pop to register</strong></p>
<p>Takes data from stack and moves it to given register.</p>
</li>
<li>
<p><strong>Move register</strong></p>
<p>Moves data between two registers.</p>
</li>
<li>
<p><strong>Call function</strong></p>
<p>Uses associated <code>FunctionQuery</code> to find and invoke function from registry.</p>
</li>
<li>
<p><strong>Branch scope</strong></p>
<p>Takes <code>bool</code> from stack and if it's <code>true</code>, it will execute Success operations set, otherwise Failure operations set if present.</p>
</li>
<li>
<p><strong>Loop scope</strong></p>
<p>Executes set of operations in an loop so that before start of iteration it takes <code>bool</code> from stack, then if it's <code>true</code>, set of operations gets executed. Important note here is to remember to always push <code>bool</code> value (telling if next iteration should be executed), before we exit child scope.</p>
</li>
<li>
<p><strong>Push scope</strong></p>
<p>Pushes new set of operations for execution, returning further execution to its parent only when child scope stops its execution.</p>
</li>
<li>
<p><strong>Pop scope</strong></p>
<p>Closest analogue can be <code>return</code> keyword, which forces scope to stop further operations execution.</p>
</li>
<li>
<p><strong>Continue scope conditionally</strong></p>
<p>Does what pop scope does, but first takes <code>bool</code> from the stack and if it is <code>false</code>, scope gets dropped.</p>
</li>
</ul>
<p>Usually we leave producing script operations to frontends, but one can create them at any time by any means. One can even create them at runtime and call newly created function in place, without adding it to registry:</p>
<pre><pre class="playground"><code class="language-rust">let function = Function::new(
    function_signature! {
        registry =&gt; mod test fn main() -&gt; (result: i32)
    },
    VmScope::&lt;AsmExpression&gt;::generate_function_body(
        ScriptBuilder::&lt;AsmExpression&gt;::default()
            .literal(AsmExpression::Literal(AsmLiteral::I32(2)))
            .literal(AsmExpression::Literal(AsmLiteral::I32(40)))
            .call_function(FunctionQuery {
                name: Some("add".into()),
                module_name: Some("lib".into()),
                ..Default::default()
            })
            .build(),
        &amp;registry,
        None,
    )
    .unwrap()
    .0
);

function.invoke(&amp;mut context, &amp;registry);
assert_eq!(context.stack().pop::&lt;i32&gt;().unwrap(), 42);</code></pre></pre>
<p>This example shows precisely how short is the path between scripts and backends - backends constructing script functions directly from script operations, and in case of <code>VmScope</code> every time we call function generated by it, we directly execute these operations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<p>In this tutorial we will be building entire custom and very simple scripting pipeline step by step, in order:</p>
<ul>
<li><a href="tutorial/./frontend.html">Frontend</a></li>
<li><a href="tutorial/./backend.html">Backend</a></li>
<li><a href="tutorial/./runner.html">Runner (REPL)</a></li>
</ul>
<p>We have choosen this particular order because each next part uses things made in its previous steps.</p>
<p><strong>This entire tutorial sits in <code>/demos/custom/</code> project on repository, if you want to look at complete project.</strong></p>
<hr />
<p>Before we start tutorials, let's provide native-side library of functions we will use in the scripts right away, as <code>library.rs</code> file:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use intuicio_core::prelude::*;
use intuicio_derive::*;

#[intuicio_function(module_name = "lib")]
fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[intuicio_function(module_name = "lib")]
fn sub(a: i32, b: i32) -&gt; i32 {
    a - b
}

#[intuicio_function(module_name = "lib")]
fn mul(a: i32, b: i32) -&gt; i32 {
    a * b
}

#[intuicio_function(module_name = "lib")]
fn div(a: i32, b: i32) -&gt; i32 {
    a / b
}

pub fn install(registry: &amp;mut Registry) {
    registry.add_function(add::define_function(registry));
    registry.add_function(sub::define_function(registry));
    registry.add_function(mul::define_function(registry));
    registry.add_function(div::define_function(registry));
}
<span class="boring">}</span></code></pre></pre>
<p>So whenever you'll see in next tutorials this line, remember it calls <code>install</code> function from <code>library.rs</code> provided above:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>crate::library::install(&amp;mut registry);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-custom-frontend"><a class="header" href="#building-custom-frontend">Building custom frontend</a></h1>
<p>This is gonna be basically a pretty much stripped down version of <code>assembler</code> frontend just to get intuition on creating frontends. For more advanced examples of frontends please take a look at frontends already made, located in <code>frontends</code> folder on repository.</p>
<hr />
<p>Let's start with defining goals for this frontend to achieve:</p>
<ul>
<li>scripts operate only on <code>i32</code> values.</li>
<li>scripts will have two operations:
<ul>
<li>push value on stack.</li>
<li>call functions that takes values from stack, performs operations on them and push results back on stack.</li>
</ul>
</li>
<li>syntax of this language has to be simple, so that:
<ul>
<li>each line is an operation or comment.</li>
<li>we put operations in reverse order so it is easier to read script as a hierarchy of function calls with its arguments indented and in ascending order.</li>
</ul>
</li>
</ul>
<p>Frontend syntax:</p>
<pre><code class="language-text">call lib div
    call lib mul
        push 3
        call lib sub
            call lib add
                push 40
                push 2
            push 10
    push 2
</code></pre>
<hr />
<p>So now let's create new project and add Intuicio dependencies:</p>
<pre><code class="language-toml">[dependencies]
intuicio-data = "*"
intuicio-core = "*"
intuicio-derive = "*"
intuicio-backend-vm = "*"
</code></pre>
<p>Then create <code>frontend.rs</code> file, where we will heep all frontend-related code, and first import these dependencies:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use intuicio_core::prelude::*;
use std::{error::Error, str::FromStr};
<span class="boring">}</span></code></pre></pre>
<p><code>intuicio_core</code> holds types related to script information, we use <code>Error</code> trait for errors propagation and <code>FromStr</code> for parsing.</p>
<hr />
<p>The most important thing to make is custom Intuiocio expression:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub enum CustomExpression {
    Literal(i32),
}

impl ScriptExpression for CustomExpression {
    fn evaluate(&amp;self, context: &amp;mut Context, _: &amp;Registry) {
        match self {
            Self::Literal(value) =&gt; {
                context.stack().push(*value);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Expressions allow to extend available operations set of Intuicio scripts to enable features specific to given frontend - here we just allow to push <code>i32</code> literals onto stack.</p>
<hr />
<p>Now we will define intermediate script types for our Custom scripting language:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type CustomScript = Vec&lt;CustomOperation&gt;;

pub enum CustomOperation {
    Comment { content: String },
    Push { value: i32 },
    Call { name: String, module_name: String },
}
<span class="boring">}</span></code></pre></pre>
<p>Next we need to implement parsing of operations from string lines to intermediate script data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FromStr for CustomOperation {
    type Err = CustomOperationError;

    fn from_str(line: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        let line = line.trim();
        if line.is_empty() {
            return Ok(Self::Comment {
                content: "".to_owned(),
            });
        }
        if line.starts_with("#") {
            return Ok(Self::Comment {
                content: line.to_owned(),
            });
        }
        let mut tokens = line.split_ascii_whitespace();
        match tokens.next() {
            Some("push") =&gt; {
                let value = tokens.next().unwrap().parse::&lt;i32&gt;().unwrap();
                Ok(Self::Push { value })
            }
            Some("call") =&gt; {
                let module_name = tokens.next().unwrap().to_owned();
                let name = tokens.next().unwrap().to_owned();
                Ok(Self::Call { name, module_name })
            }
            _ =&gt; Err(CustomOperationError {
                operation: line.to_owned(),
            }),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Also don't forget to implement our parsing error type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub struct CustomOperationError {
    pub operation: String,
}

impl std::fmt::Display for CustomOperationError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, "Unsupported operation: `{}`", self.operation)
    }
}

impl Error for CustomOperationError {}
<span class="boring">}</span></code></pre></pre>
<hr />
<p>After that we need to implement script compilation from intermediate to Intuicio scripts data, so scripts will be understood by Intuicio backend:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl CustomOperation {
    pub fn compile_operation(&amp;self) -&gt; Option&lt;ScriptOperation&lt;'static, CustomExpression&gt;&gt; {
        match self {
            Self::Comment { .. } =&gt; None,
            Self::Push { value } =&gt; Some(ScriptOperation::Expression {
                expression: CustomExpression::Literal(*value),
            }),
            Self::Call { name, module_name } =&gt; Some(ScriptOperation::CallFunction {
                query: FunctionQuery {
                    name: Some(name.to_owned().into()),
                    module_name: Some(module_name.to_owned().into()),
                    ..Default::default()
                },
            }),
        }
    }

    pub fn compile_script(
        operations: &amp;[CustomOperation],
    ) -&gt; ScriptHandle&lt;'static, CustomExpression&gt; {
        operations
            .iter()
            .rev()
            .filter_map(|operation| operation.compile_operation())
            .collect::&lt;Vec&lt;_&gt;&gt;()
            .into()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>In <code>compile_script</code> method we iterate over operations in reverse order, because human-readable side of the scripts expects function call and then its parameters, while Intuicio scripts expect computer-readable order of arguments first, then function call.</p>
<hr />
<p>Finally we create scripts content parser so it can be used to parse byte strings into intermediate type scripts:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CustomContentParser;

impl BytesContentParser&lt;CustomScript&gt; for CustomContentParser {
    fn parse(&amp;self, bytes: Vec&lt;u8&gt;) -&gt; Result&lt;CustomScript, Box&lt;dyn Error&gt;&gt; {
        Ok(String::from_utf8(bytes)?
            .lines()
            .filter(|line| !line.is_empty())
            .map(|line| CustomOperation::from_str(line))
            .collect::&lt;Result&lt;CustomScript, _&gt;&gt;()?)
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<p>Now let's create <code>main.rs</code> file, where we will test this frontend, first import dependencies:</p>
<pre><pre class="playground"><code class="language-rust">mod frontend;
mod library;

use crate::frontend::*;
use intuicio_backend_vm::prelude::*;
use intuicio_core::prelude::*;

fn main() {
    // next steps go here.
}</code></pre></pre>
<p>Then parse and compile some script:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let script = b"
call lib div
    call lib mul
        push 3
        call lib sub
            call lib add
                push 40
                push 2
            push 10
    push 2
";
let script = CustomContentParser.parse(script.to_vec()).unwrap();
let script = CustomOperation::compile_script(&amp;script);
<span class="boring">}</span></code></pre></pre>
<p>Next, create and setup registry:</p>
<pre><pre class="playground"><code class="language-rust">let mut registry = Registry::default().with_basic_types();
crate::library::install(&amp;mut registry);
registry.add_function(Function::new(
    function_signature! {
        registry =&gt; mod main fn main() -&gt; (result: i32)
    },
    VmScope::&lt;CustomExpression&gt;::generate_function_body(script, None)
        .unwrap()
        .0,
));</code></pre></pre>
<p>As you can see, our scripts do not define functions, rather operations that belong to single one, so we create new main function and add it to the registry. We also use <code>VmScope</code> from VM backend to test this frontend in already existing VM backend, until we create dedicated backend ourselves.</p>
<p>Final thing to do is to create host and test frontend:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut host = Host::new(Context::new(1024, 1024, 1024), registry.into());
let (result,) = host
    .call_function::&lt;(i32,), _&gt;("main", "main", None)
    .unwrap()
    .run(());
assert_eq!(result, 48);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-custom-backend"><a class="header" href="#building-custom-backend">Building custom backend</a></h1>
<p>Goal for our custom backend is to simplify Virtual Machine by limiting its execution to only expressions and function calls, everything else will be treated with errors when used.</p>
<p>You might ask:</p>
<blockquote>
<p>Ok, but our frontend already works on official VM backend, why creating custom one?</p>
</blockquote>
<p>And you're completely right, there is no need for custom backend, although showcasing how one could create custom backend might help gain understanding and spark some ideas or even make someone improve if not create completely new backend that's gonna execute scripts much faster than what official VM backend offers!</p>
<p>So yeah, <strong>this part of tutorial is educational only</strong>, there is no need to create custom backends for custom frontends.</p>
<hr />
<p>Now let's start with creating <code>backend.rs</code> as part of our existing project and import dependencies, and create custom VM scope type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use intuicio_core::prelude::*;

pub struct CustomScope&lt;'a, SE: ScriptExpression&gt; {
    handle: ScriptHandle&lt;'a, SE&gt;,
    position: usize,
}

impl&lt;'a, SE: ScriptExpression&gt; CustomScope&lt;'a, SE&gt; {
    pub fn new(handle: ScriptHandle&lt;'a, SE&gt;) -&gt; Self {
        Self {
            handle,
            position: 0,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, it is generic over the expression type of scripts so this backend could be used by any frontend, limiting scripts execution to expressions and function calls only.</p>
<p>Next we implement simple VM execution of entire script operations set:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, SE: ScriptExpression&gt; CustomScope&lt;'a, SE&gt; {
    pub fn run(&amp;mut self, context: &amp;mut Context, registry: &amp;Registry) {
        while let Some(operation) = self.handle.get(self.position) {
            match operation {
                ScriptOperation::None =&gt; {
                    self.position += 1;
                }
                ScriptOperation::Expression { expression } =&gt; {
                    expression.evaluate(context, registry);
                    self.position += 1;
                }
                ScriptOperation::CallFunction { query } =&gt; {
                    let handle = registry
                        .functions()
                        .find(|handle| query.is_valid(handle.signature()))
                        .unwrap_or_else(|| {
                            panic!("Could not call non-existent function: {:#?}", query)
                        });
                    handle.invoke(context, registry);
                    self.position += 1;
                }
                _ =&gt; unreachable!("Trying to perform unsupported operation!"),
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>And last thing for this file is to implement <code>ScriptFunctionGenerator</code> for custom VM scope, so it will take any script and turn it into function body that will be provided later to function definitions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;SE: ScriptExpression + 'static&gt; ScriptFunctionGenerator&lt;SE&gt; for CustomScope&lt;'static, SE&gt; {
    type Input = ();
    type Output = ();

    fn generate_function_body(
        script: ScriptHandle&lt;'static, SE&gt;,
        ignore: Self::Input,
    ) -&gt; Option&lt;(FunctionBody, Self::Output)&gt; {
        Some((
            FunctionBody::closure(move |context, registry| {
                Self::new(script.clone()).run(context, registry);
            }),
            ignore,
        ))
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<p>Finally we need to change our <code>main.rs</code> file slightly to use custom VM scope instead of official VM scope.</p>
<p>First we need to make new dependency imports in place of old ones:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod backend;
mod frontend;
mod library;

use crate::backend::*;
use crate::frontend::*;
use intuicio_core::prelude::*;
<span class="boring">}</span></code></pre></pre>
<p>We can also remove <code>intuicio-backend-vm</code> dependency from <code>Cargo.toml</code> since it won't be used anymore.</p>
<p>Next the only thing we change in <code>main</code> function is we just replace our <code>main</code> scripting function definition into:</p>
<pre><pre class="playground"><code class="language-rust">registry.add_function(Function::new(
    function_signature! {
        registry =&gt; mod main fn main() -&gt; (result: i32)
    },
    CustomScope::&lt;CustomExpression&gt;::generate_function_body(script, ())
        .unwrap()
        .0,
));</code></pre></pre>
<p>So it will generate function body that runs custom VM scope with previously compiled script.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-custom-runner"><a class="header" href="#building-custom-runner">Building custom runner</a></h1>
<p>Inthis part of tutorial we will be creating REPL solution that will prompts users to type operations in each next line and issue execution of collected operations as single script.</p>
<hr />
<p>First clear entire <code>main.rs</code> file, and start with importing new set of dependencies:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod backend;
mod frontend;
mod library;

use crate::backend::*;
use crate::frontend::*;
use intuicio_core::prelude::*;
use std::str::FromStr;
<span class="boring">}</span></code></pre></pre>
<p>Then we create our REPL structure that will hold both collected script operations and host that will run provided scripts:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Repl {
    script: CustomScript,
    host: Host,
}

impl Default for Repl {
    fn default() -&gt; Self {
        let mut registry = Registry::default().with_basic_types();
        crate::library::install(&amp;mut registry);
        let context = Context::new(1024, 1024, 1024);
        Self {
            script: Default::default(),
            host: Host::new(context, registry.into()),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Next we need to implement feeding lines functionality, that will ask user for next operation, parse, compile and either collect into script or execute collected script if user types empty line:</p>
<pre><pre class="playground"><code class="language-rust">impl Repl {
    fn feed_line(&amp;mut self) {
        let mut line = String::default();
        if let Err(error) = std::io::stdin().read_line(&amp;mut line) {
            println!("* Could not read line: {}", error);
        }
        if line.trim().is_empty() {
            let (context, registry) = self.host.context_and_registry();
            let script = CustomOperation::compile_script(&amp;self.script);
            let body = match CustomScope::&lt;CustomExpression&gt;::generate_function_body(script, ()) {
                Some(body) =&gt; body.0,
                None =&gt; {
                    println!("Could not generate custom function body!");
                    return;
                }
            };
            let function = Function::new(
                function_signature! {
                    registry =&gt; mod main fn main() -&gt; (result: i32)
                },
                body,
            );
            function.invoke(context, registry);
            if let Some(value) = context.stack().pop::&lt;i32&gt;() {
                println!("* Completed with result: {}", value);
            } else {
                println!("* Completed!");
            }
            self.script.clear();
        } else {
            match CustomOperation::from_str(&amp;line) {
                Ok(operation) =&gt; self.script.push(operation),
                Err(error) =&gt; println!("* Could not parse operation: {}", error),
            }
        }
    }
}</code></pre></pre>
<hr />
<p>Finally here comes <code>main</code> function that runs REPL in a loop:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut repl = Repl::default();
    println!("Custom REPL.\nPlease feed operation per line or type empty line to execute:");
    loop {
        repl.feed_line();
    }
}</code></pre></pre>
<hr />
<p>Let's test it:</p>
<pre><code class="language-text">$ cargo run
Custom REPL.
Please feed operation per line or type empty line to execute:
call lib add
push 40
push 2

* Completed with result: 42
</code></pre>
<hr />
<p>And with that our simple tutorial completes - i hope you have learned something new today and i hope it gave you some intuition on how to create entire scripting solution with Intuicio!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="official-frontends"><a class="header" href="#official-frontends">Official frontends</a></h1>
<p>Intuicio platform provides set of official frontends both as languages dedicated to specific domains and serving as an example of how more complex frontends are being designed:</p>
<ul>
<li><a href="official-frontends/./assembler/index.html"><strong>Assembler</strong></a></li>
<li><a href="official-frontends/./serde/index.html"><strong>Serde</strong></a></li>
<li><a href="official-frontends/./simpleton/index.html"><strong>Simpleton</strong></a></li>
<li><a href="official-frontends/./vault/index.html"><strong>Vault</strong></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assembler"><a class="header" href="#assembler">Assembler</a></h1>
<p>Low level text-based language that is the closest one to Intuicio script information data format. Useful for in-game operation systems.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serde"><a class="header" href="#serde">Serde</a></h1>
<p>Low level data-based language to supports scripts that can be defined in any format supported by <code>serde</code> (for example: json, yaml, toml, lexpr and more). Useful as intermediate stage between editors and scripting.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vault"><a class="header" href="#vault">Vault</a></h1>
<p>An attempt to high level text-based strongly typed scripting language with lexpr syntax.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simpleton"><a class="header" href="#simpleton">Simpleton</a></h1>
<p>High level text-based scripting language.</p>
<p>Key features:</p>
<ul>
<li>Dynamically typed.</li>
<li>Influenced by <strong>JavaScript</strong> and <strong>Python</strong>.</li>
<li>Simple to understand and learn.</li>
<li>Rich standard library.</li>
</ul>
<p><strong>Useful for scripting tools and game logic, where simplicity and ergonomics is vastly more important than performance.</strong></p>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<p>Simpleton was created for simplicity in mind as priority, mostly for allowing to create tools and simple game logic the easiest way possible.</p>
<p>It also has an educational value to showcase Intuicio users how one can create fully fledged dynamically typed scripting language - something that might be counter intuitive since Intuicio is rather strongly typed scripting platform. We achieve that by introducing Reference, Type and Function as fundamental Simpleton types, so that entire frontend is built around interactions with these types.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<pre><code class="language-javascript">mod main {
    func main(args) {
        console::log_line("Hello World!");
        
        var fib = main::fib(10);
        console::log_line(debug::debug(fib, false));
    }

    func fib(n) {
        if math::less_than(n, 2) {
            return n;
        } else {
            return math::add(
                main::fib(math::sub(n - 1)),
                main::fib(math::sub(n - 2)),
            );
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-reference"><a class="header" href="#language-reference">Language reference</a></h1>
<p>Let's start with saying that <strong>Simpleton is not an OOP language</strong>, you won't also see any class methods, inheritance or dynamic method dispatch seen in other OOP scripting languages.</p>
<p><strong>Simpleton is rather functional/procedural scripting language</strong> that operates on structures for data transformations.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of contents:</a></h2>
<ul>
<li><a href="official-frontends/simpleton/language-reference.html#script-file-structure">Script file structure</a></li>
<li><a href="official-frontends/simpleton/language-reference.html#structures">Structures</a></li>
<li><a href="official-frontends/simpleton/language-reference.html#functions">Functions</a></li>
<li><a href="official-frontends/simpleton/language-reference.html#closures">Closures</a></li>
<li><a href="official-frontends/simpleton/language-reference.html#primitive-types">Primitive types</a></li>
<li><a href="official-frontends/simpleton/language-reference.html#variables">Variables</a></li>
<li><a href="official-frontends/simpleton/language-reference.html#if-else-branching">If-else branching</a></li>
<li><a href="official-frontends/simpleton/language-reference.html#while-loops">While loops</a></li>
<li><a href="official-frontends/simpleton/language-reference.html#for-loops">For loops</a></li>
<li><a href="official-frontends/simpleton/language-reference.html#imports">Imports</a></li>
</ul>
<h2 id="script-file-structure"><a class="header" href="#script-file-structure">Script file structure</a></h2>
<p>Every script file consists of module definition and module items such as structures and functions:</p>
<pre><code class="language-javascript">mod vec2 {
    struct Vec2 { x, y }

    func new(x, y) {
        return vec2::Vec2 { x, y };
    }

    func add(a, b) {
        return vec2::Vec2 {
            x: math::add(a.x, b.x),
            y: math::add(a.y, b.y),
        };
    }
}
</code></pre>
<p>General rule of thumb is that one file describes one module and preferably one structure (if any) so functions in that module are working in context of that structure (somewhat similarly to how GDscript treats its files to some extent).</p>
<p>So later these module types are operated on like this:</p>
<pre><code class="language-javascript">mod main {
    import "vec2";

    func main() {
        var a = vec2::new(0.0, 1.0);
        var b = vec2::new(1.0, 0.0);
        var c = vec2::add(a, b);
        // vec2::Vec2 { x: 1.0, y: 1.0 }
        console::log_line(debug::debug(c, false));
    }
}
</code></pre>
<p>First question that comes into mind is:</p>
<blockquote>
<p>Why there are <code>add</code> function calls instead of operators being used?</p>
</blockquote>
<p><strong>Simpleton does not have operators</strong> - Simpleton believes in being explicit. If something is doing what function calls does, it should be called as function.</p>
<p>The only exceptions are array and map accessors:</p>
<pre><code class="language-javascript">var array = [0, 1, 2];
var array_item = array[1];

var map = { a: 0, b: 1, c: 2 };
var map_item = map{"b"};
</code></pre>
<h2 id="structures"><a class="header" href="#structures">Structures</a></h2>
<p>Every structure is defined by its name and list of field names:</p>
<pre><code class="language-javascript">struct Vec2 { x, y }
</code></pre>
<p>The reason for that is that structures defined in simpleton are concrete objects that take up space defined by number of references they hold, they aren't dynamically sized bags of properties like in many scripting languages.</p>
<p>If we have an object of <code>vec2::Vec2</code> type and we want to access its <code>x</code> field for reads or writes, it is guaranteed this field exists in the object and we get or set its reference.</p>
<p>And the opposite is true too - if we try to access object field that is not defined in its type, we will get runtime error.</p>
<p>Since Simpleton is not an OOP language, we not only do not have class methods, but also we do not have constructors, therefore we construct objects in-place like this:</p>
<pre><code class="language-javascript">var v = vec2::Vec2 { x: 42.0 };
</code></pre>
<p>What this does is Simpleton creates default object of type <code>vec2::Vec2</code> and then applies values to fields listed in brackets - this also means that if we omit some fields, object will have their references <code>null</code>ed.</p>
<p>Therefore if object expects some specific constraints on the object fields, it's good practice to make functions that return new object in-place with fields filled with arguments validated by that function:</p>
<pre><code class="language-javascript">func new(x, y) {
    debug::assert(
        math::equals(reflect::type_of(x), &lt;struct math::Real&gt;),
        "`x` is not a number!",
    );
    debug::assert(
        math::equals(reflect::type_of(y), &lt;struct math::Real&gt;),
        "`y` is not a number!",
    );
    return vec2::Vec2 { x, y };
}
</code></pre>
<p>Additionally in rare situations when we do not know object type at compile-time, we can construct objects by <code>Type</code> object found at runtime:</p>
<pre><code class="language-javascript">var v = reflect::new(&lt;struct vec2::Vec2&gt;, { x: 42 });
</code></pre>
<p>This is useful especially in case of deserialization, where type is part of deserialized data:</p>
<pre><code class="language-javascript">var data = {
    type_name: "Vec2",
    type_module_name: "vec2",
    properties: {
        x: 42.0,
    },
};
var type = reflect::find_type_by_name(data.type_name, data.type_module_name);
var v = reflect::new(type, data.properties);
</code></pre>
<p>And finally to get or set value from object field we use <code>.</code> delimiter between object and its field name:</p>
<pre><code class="language-javascript">var v = vec2::Vec2 { x: 42 };
v.x = math::add(v.x, 10);
</code></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>Every function is defined by its name, arguments list and function statements as its body:</p>
<pre><code class="language-javascript">func sum(a, b, c) {
    console::log_line(
        text::format("sum: {0}, {1}, {2}", [
            reflect::to_text(a),
            reflect::to_text(b),
            reflect::to_text(c),
        ]),
    );

    return math::add(
        math::add(a, b),
        c,
    );
}
</code></pre>
<p>As you can see there is <code>return</code> keyword - it is used to inform Simpleton that we want to exit current function with given value.</p>
<p>Functions always return some reference, if function does not have <code>return</code> statement in there, it implicitly returns <code>null</code>. We can also <code>return null;</code> if we want to exit function without value.</p>
<p>Later functions can be called by providing their module name, function name and arguments:</p>
<pre><code class="language-javascript">var v = main::sum(1, 2, 3);
</code></pre>
<p>If we don't know function at compile-time, we can call it at runtime by <code>Function</code> object:</p>
<pre><code class="language-javascript">var v = reflect::call(&lt;func main::sum&gt;, [1, 2, 3]);
</code></pre>
<p>We can also find function type by its name and module name:</p>
<pre><code class="language-javascript">var function = reflect::find_function_by_name("sum", "main");
var v = reflect::call(function, [1, 2, 3]);
</code></pre>
<h2 id="closures"><a class="header" href="#closures">Closures</a></h2>
<p>Closures are special anonymous functions that can also capture variables from outer scope:</p>
<pre><code class="language-javascript">var a = 40;
var closure = @[a](b) {
    return math::add(a, b);
};
var v = closure::call(closure, [b]);
</code></pre>
<p>Under the hood, closures are objects that store reference to <code>Function</code> object and list of captured references, and are compiled into actual functions like this:</p>
<pre><code class="language-javascript">mod _closures {
    func _0(a, b) {
        return math::add(a, b);
    }
}
</code></pre>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive types</a></h2>
<ul>
<li><code>null</code> - reference that points to nothing.</li>
<li><code>Boolean</code> - can hold either <code>true</code> or <code>false</code>.</li>
<li><code>Integer</code> - their literals are numbers without rational part: <code>42</code>. Additionally there are hex (<code>#A8</code>) and binary (<code>$1011</code>) integer literals.</li>
<li><code>Real</code> - their literals are numbers with rational part: <code>4.2</code>.</li>
<li><code>Text</code> - also known in other languages as strings of UTF8 characters: <code>"Hello World!"</code>.</li>
<li><code>Array</code> - sequence of value references: <code>[0, 1, 2]</code>. We can access its items with: <code>array[0]</code>.</li>
<li><code>Map</code> - unordered table of key-value pairs: <code>{ a: 0, b: 1, c: 2 }</code>. We can access its items with: <code>map{"a"}</code>.</li>
</ul>
<p>It's worth noting that all objects, even <code>Boolean</code>, <code>Integer</code> and <code>Real</code> are boxed object - choice made for the sake of simplicity of language implementation, but in the future they might endup unboxed to improve performance - <em>for now we don't mind them being boxed, at this point in development, performance is not the priority</em>.</p>
<h2 id="variables"><a class="header" href="#variables">Variables</a></h2>
<p>Variables are local to the function, they are name aliases for references to values. You define variable with its value like this:</p>
<pre><code class="language-javascript">var answer = 42;
</code></pre>
<p>You can also assign new values to existing variables:</p>
<pre><code class="language-javascript">answer = 10;
</code></pre>
<p>Since variables are just named references local to given function, you can assign different type values to them than what was stored there at creation:</p>
<pre><code class="language-javascript">var v = 42;
v = "Hello World!";
</code></pre>
<p>To get value behind variable you just use its name:</p>
<pre><code class="language-javascript">var a = 42;
console::log_line(reflect::to_text(a));
</code></pre>
<h2 id="if-else-branching"><a class="header" href="#if-else-branching">If-else branching</a></h2>
<p>Branching allows to execute some scope if condition succeeds:</p>
<pre><code class="language-javascript">if math::equals(a, 42) {
    console::log_line("`a` equals 42!");
}
</code></pre>
<p>One can also specify <code>else</code> scope in case condition fails:</p>
<pre><code class="language-javascript">if math::equals(a, 42) {
    console::log_line("`a` equals 42!");
} else {
    console::log_line("`a` does not equals 42!");
}
</code></pre>
<h2 id="while-loops"><a class="header" href="#while-loops">While loops</a></h2>
<p>While loops allows to execute some scope repeatedly as long as condition succeeds:</p>
<pre><code class="language-javascript">var a = 0;
while math::less_than(a, 42) {
    a = math::add(a, 1);
}
</code></pre>
<h2 id="for-loops"><a class="header" href="#for-loops">For loops</a></h2>
<p>For loops combined with iterators allow to iterate on values yielded by them until <code>null</code> value is yielded, which signals end of iteration:</p>
<pre><code class="language-javascript">// 2, 3, 4
for value in iter::walk(2, 3) {
    console::log_line(debug::debug(value, false));
}

// 0, 1, 2
for value in iter::range(0, 3) {
    console::log_line(debug::debug(value, false));
}

var v = [0, 1, 2];
// 2, 1, 0
for value in array::iter(v, true) {
    console::log_line(debug::debug(value, false));
}

var v = { a: 0, b: 1, c: 2};
// { key: "a", value: 1 }, { key: "b", value: 2 }, { key: "c", value: 3 }
for pair in map::iter(v) {
    console::log_line(debug::debug(pair, false));
}

var iter = iter::build([
    iter::range(0, 10),
    [&lt;func iter::filter&gt;, @[](value) {
        return math::equals(
            math::modulo(value, 2),
            0,
        );
    }],
]);
// 0, 2, 4, 6, 8
for pair in iter {
    console::log_line(debug::debug(pair, false));
}
</code></pre>
<h2 id="imports"><a class="header" href="#imports">Imports</a></h2>
<p>Packages are built by traversing modules tree - this tree is defined by entry module and its dependencies specified by imports:</p>
<pre><code class="language-javascript">mod main {
    import "vec2.simp";

    func main() {
        var a = vec2::Vec2 { x: 1, y: 0 };
        var b = vec2::Vec2 { x: 0, y: 1 };
        // vec2::Vec2 { x: 1, y: 1 }
        var c = vec2::add(a, b);
    }
}
</code></pre>
<pre><code class="language-javascript">mod vec2 {
    struct Vec2 { x, y }

    func add(a, b) {
        return vec2::Vec2 {
            x: math::add(a.x, b.x),
            y: math::add(a.y, b.y),
        };
    }
}
</code></pre>
<p>We provide relative path to another module file with <code>import</code> keyword.</p>
<p>It's worth noting that file extensions can e omited there, compiler will assume <code>simp</code> extension then.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference"><a class="header" href="#api-reference">API reference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reflect"><a class="header" href="#reflect">Reflect</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closure"><a class="header" href="#closure">Closure</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debug"><a class="header" href="#debug">Debug</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="console"><a class="header" href="#console">Console</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="math"><a class="header" href="#math">Math</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array"><a class="header" href="#array">Array</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="map"><a class="header" href="#map">Map</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text"><a class="header" href="#text">Text</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytes"><a class="header" href="#bytes">Bytes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="json"><a class="header" href="#json">JSON</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="toml"><a class="header" href="#toml">TOML</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators"><a class="header" href="#iterators">Iterators</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event"><a class="header" href="#event">Event</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="promise"><a class="header" href="#promise">Promise</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-system"><a class="header" href="#file-system">File system</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="process"><a class="header" href="#process">Process</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="network"><a class="header" href="#network">Network</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="jobs-multithreading"><a class="header" href="#jobs-multithreading">Jobs (multithreading)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="official-runners"><a class="header" href="#official-runners">Official runners</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simpleton-1"><a class="header" href="#simpleton-1">Simpleton</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference-1"><a class="header" href="#api-reference-1">API reference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="script-1"><a class="header" href="#script-1">Script</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alchemyst"><a class="header" href="#alchemyst">Alchemyst</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference-2"><a class="header" href="#api-reference-2">API reference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="color"><a class="header" href="#color">Color</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vec2"><a class="header" href="#vec2">Vec2</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image"><a class="header" href="#image">Image</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="image-pipeline"><a class="header" href="#image-pipeline">Image Pipeline</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
