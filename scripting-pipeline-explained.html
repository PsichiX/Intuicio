<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Scripting pipeline explained - Intuicio - Modular scripting platform for Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="scripting-pipeline-explained.html" class="active"><strong aria-hidden="true">2.</strong> Scripting pipeline explained</a></li><li class="chapter-item expanded "><a href="building-custom-frontend.html"><strong aria-hidden="true">3.</strong> Building custom frontend</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Intuicio - Modular scripting platform for Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="scripting-pipeline-explained"><a class="header" href="#scripting-pipeline-explained">Scripting pipeline explained</a></h1>
<p>Here we will attempt to explain entire scripting pipeline using examples of building blocks already made.</p>
<h2 id="first-things-first"><a class="header" href="#first-things-first">First things first</a></h2>
<p>Now let's pick some building blocks. For backend we will use <code>intuicio-backend-vm</code>, and for frontend we will use <code>intuicio-frontend-assembler</code> (this may look quite unintuitive but it will allow us better explain how bindings work with scripts, so please bare with me for a little).</p>
<p>Create new Cargo project and add these dependencies:</p>
<pre><code class="language-toml">[dependencies]
intuicio-core = &quot;*&quot;
intuicio-derive = &quot;*&quot;
intuicio-backend-vm = &quot;*&quot;
intuicio-frontend-assembler = &quot;*&quot;
</code></pre>
<p>Once we have created new project, now in <code>main.rs</code> import these:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use intuicio_backend_vm::prelude::*;
use intuicio_core::prelude::*;
use intuicio_derive::*;
use intuicio_frontend_assembler::*;
<span class="boring">}</span></code></pre></pre>
<hr />
<p>Now let's define a simple function that our script will run:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[intuicio_function(module_name = &quot;lib&quot;)]
fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
<span class="boring">}</span></code></pre></pre>
<p>We use procedural attribute macro that will generate and fill <code>Function</code> type with all the information about this function. We could also construct it by hand, or even with procedural macro like this to register its result into <code>Registry</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>registry.add_function(define_function! {
    registry =&gt; mod lib fn add(a: i32, b: i32) -&gt; (result: i32) {
        (a + b,)
    }
});
<span class="boring">}</span></code></pre></pre>
<p>But for the sake of simplicity, just stay with <code>intuicio_function</code> macro.</p>
<hr />
<p>Then in <code>main</code> function first thing we should create is <code>Registry</code> to store all definitions of structures and functions, both native and script side ones, we also add basic types to not have to add them manually, and register defined function into that registry:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut registry = Registry::default().with_basic_types();
registry.add_function(add::define_function());
<span class="boring">}</span></code></pre></pre>
<p>Like we sait before, registry should hold all the structures and functions information that scripts can interact with, and because Registry turns immutable once it gets into execution phase, better to do that from the get go - you won't be able to modify registry later.</p>
<hr />
<p>Next step is to load, parse, compile and install assembly script into registry:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut content_provider = FileContentProvider::new(&quot;iasm&quot;, AsmContentParser);
AsmPackage::new(&quot;./resources/main.iasm&quot;, &amp;mut content_provider)
    .unwrap()
    .compile()
    .install::&lt;VmScope&lt;AsmExpression&gt;&gt;(&amp;mut registry, None);
<span class="boring">}</span></code></pre></pre>
<p><code>FileContentProvider</code> allows to pull script content from file system, <code>AsmContentParser</code> parses assembly script content into <code>AsmPackage</code> (intermediate representation of assembly scripts), <code>VmScope</code> is a container for script operations compiled from <code>AsmPackage</code> and finally <code>AsmExpression</code> is a set of custom operations that assembly scripting language performs. Expressions are an essential part of Intuicio scripting, since bare bones script data has very limited, universal set of basic operations required to make scripts call functions and move data between stack and registers - expressions allow extending set of operations, in case of <code>AsmExpression</code> scripts can push literals into stack and drop and forget value from stack.</p>
<hr />
<p>Last step is to construct <code>Context</code> and put it with <code>Registry</code> into <code>Host</code> that will allow calling any function from the registry:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let context = Context::new(
    // stack bytes capacity.
    1024,
    // registers bytes capacity.
    1024,
    // heap page capacity.
    1024,
);
let mut host = Host::new(context, RegistryHandle::new(registry));
let (result,) = host
    .call_function::&lt;(i32,), _&gt;(
        // function name.
        &quot;main&quot;,
        // module name.
        &quot;test&quot;,
        // structure name if function belongs to one.
        None,
    )
    .unwrap()
    .run(());
assert_eq!(result, 42);
<span class="boring">}</span></code></pre></pre>
<hr />
<p>Now the only thing what's left is to create <code>./resources/main.iasm</code> file and fill it with script code:</p>
<pre><code>mod test {
    fn main() -&gt; (result: struct i32) {
        literal 40 i32;
        literal 2 i32;
        call mod lib fn add;
    }
}
</code></pre>
<p>We can see all this script is doing is pushing data on stack and calling a function - this will help us explain what is happening much easier.</p>
<h2 id="how-data-moves"><a class="header" href="#how-data-moves">How data moves</a></h2>
<p>Let's start with showing how our <code>add</code> function looks actually looks like to <code>Host</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(context: &amp;mut Context, registry: &amp;Registry) {
    let a = context.stack().pop::&lt;i32&gt;().unwrap();
    let b = context.stack().pop::&lt;i32&gt;().unwrap();
    let result = a + b;
    context.stack().push(result);
}
<span class="boring">}</span></code></pre></pre>
<p>Now from the example above we can see that execution starts from application-space when we tell <code>Host</code> to find <code>main</code> function of <code>test</code> module in host's registry, once is found, host passes its <code>Context</code> and <code>Registry</code> to function generated from script.</p>
<p>This is how <code>test::main</code> script function would look like to <code>Host</code> when converted to Rust:</p>
<pre><pre class="playground"><code class="language-rust">fn main(context: &amp;mut Context, registry: &amp;Registry) {
    context.stack().push(40_i32);
    context.stack().push(2_i32);
    registry
        .find_function(FunctionQuery {
            name: Some(&quot;add&quot;.into()),
            module_name: Some(&quot;lib&quot;.into()),
            ..Default::default()
        })
        .unwrap()
        .invoke(context, registry);
}</code></pre></pre>
<p>So both together simply reduce to:</p>
<pre><pre class="playground"><code class="language-rust">fn main(context: &amp;mut Context, registry: &amp;Registry) {
    context.stack().push(40_i32);
    context.stack().push(2_i32);
    add(context, registry);
}</code></pre></pre>
<p>And this is basically exactly how and why Intuicio doesn't care about which side (script or native) calls what side - both script and native sides are calling each other the same way, and <code>VmScope</code> is just a container for script operations in the middle of interactions to make script side look the same as native side to host.</p>
<h1 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h1>
<p>To summarize, Intuicio is actually <strong><em>just</em></strong> an engine to move data from place to place via stack, it doesn't care what is the data, it doesn't specify limits on the types of data (other than data has to be owned), it also doesn't care what is the place this data moves to, all it does is moves the data and both script and native side tells it when to move what data - simple as that!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="building-custom-frontend.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="building-custom-frontend.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
