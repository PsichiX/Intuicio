<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Anatomy of a Host - Intuicio - Modular scripting platform for Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="scripting-pipeline-explained.html"><strong aria-hidden="true">2.</strong> Scripting pipeline explained</a></li><li class="chapter-item expanded "><a href="anatomy-of-a-host.html" class="active"><strong aria-hidden="true">3.</strong> Anatomy of a Host</a></li><li class="chapter-item expanded "><a href="anatomy-of-a-script.html"><strong aria-hidden="true">4.</strong> Anatomy of a Script</a></li><li class="chapter-item expanded "><a href="building-custom-frontend.html"><strong aria-hidden="true">5.</strong> Building custom frontend</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Intuicio - Modular scripting platform for Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="anatomy-of-a-host"><a class="header" href="#anatomy-of-a-host">Anatomy of a Host</a></h1>
<p><code>Host</code> is just a handy container for <code>Context</code> and <code>Registry</code> that simplifies calling functions registered in <code>Registry</code> within given <code>Context</code>.</p>
<h2 id="registry"><a class="header" href="#registry">Registry</a></h2>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<p><code>Registry</code> contains all structures and functions that both scripting and native side expose for scripting to interact with.</p>
<p>Here is an example of how to register functions both from native and script sides:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[intuicio_function(module_name = &quot;lib&quot;)]
fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

let mut registry = Registry::default().with_basic_types();
registry.add_function(add::define_function());
let mut content_provider = FileContentProvider::new(&quot;iasm&quot;, AsmContentParser);
AsmPackage::new(&quot;main.iasm&quot;, &amp;mut content_provider)
    .unwrap()
    .compile()
    .install::&lt;VmScope&lt;AsmExpression&gt;&gt;(&amp;mut registry, None);
<span class="boring">}</span></code></pre></pre>
<p>Of course we don't actually require frontends to register script-side functions and structures, here is an example of how one could create raw scripted function, knowing the backend it's gonna use (<code>VmScope</code> here):</p>
<pre><pre class="playground"><code class="language-rust">registry.add_function(
    VmScope::&lt;AsmExpression&gt;::generate_function(
        &amp;ScriptFunction {
            signature: function_signature! {
                registry =&gt; mod test fn main() -&gt; (result: i32)
            },
            script: ScriptBuilder::&lt;AsmExpression&gt;::default()
                .literal(AsmExpression::Literal(AsmLiteral::I32(2)))
                .literal(AsmExpression::Literal(AsmLiteral::I32(40)))
                .call_function(FunctionQuery {
                    name: Some(&quot;add&quot;.into()),
                    module_name: Some(&quot;lib&quot;.into()),
                    ..Default::default()
                })
                .build(),
        },
        &amp;registry,
        None,
    )
    .unwrap()
    .0,
);</code></pre></pre>
<p>And as we can see above, we can use completely different backends for each function we want to register, therefore in principle, one application can run multiple backends, not forcing user to use only one.</p>
<blockquote>
<p>Also remember that since Intuicio is all about moving data into and out of function calls, every function that we want to call, has to be always registered in the registry and registry cannot be modified when used in function calls!</p>
</blockquote>
<h3 id="queries"><a class="header" href="#queries">Queries</a></h3>
<p>If user wants to call function from registry, user has to find it first and to do that we use <code>FunctionQuery</code> that defines search parameters for registry to filter functions with:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (result,) = registry.find_function(FunctionQuery {
    name: Some(&quot;add&quot;.into()),
    module_name: Some(&quot;lib&quot;.into()),
    ..Default::default()
})
.expect(&quot;`lib::add` function not found!&quot;)
.call::&lt;(i32,), _&gt;(&amp;mut context, &amp;registry, (40_i32, 2_i32), true);
assert_eq!(result, 42);
<span class="boring">}</span></code></pre></pre>
<p>When we want to find and call registered function from within another native function, we should be able as long as native-side function has access to context and registry:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[intuicio_function(module_name = &quot;script&quot;, use_context, use_registry)]
fn script_add(context: &amp;mut Context, registry: &amp;Registry, a: i32, b: i32) -&gt; i32 {
    context.stack().push(b);
    context.stack().push(a);
    registry.find_function(FunctionQuery {
        name: Some(&quot;add&quot;.into()),
        module_name: Some(&quot;lib&quot;.into()),
        ..Default::default()
    })
    .expect(&quot;`lib::add` function not found!&quot;)
    .invoke(context, registry);
    context.stack().pop::&lt;i32&gt;().expect(&quot;Expected to return `i32`!&quot;)
}
<span class="boring">}</span></code></pre></pre>
<p>Btw. in snippet above we perform function invoke instead of a call, and notice order of pushing values into stack - by design native functions expect to pop their arguments from first to last argument, and push its result in reverse order to match later function calls proper argument pop order. For convienience it is advised to perform function calls instead of invokes, because function calls keep proper stack push and pop order on their own.</p>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<p><code>Context</code> is a container that holds:</p>
<ul>
<li>
<p><strong>Stack</strong></p>
<p>Used to move data between function calls.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>context.stack().push(42_i32);
assert_eq!(context.stack().pop::&lt;i32&gt;().unwrap(), 42);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Registers</strong></p>
<p>Indexed data storage, the closest analogue for local function variables.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (stack, registers) = context.stack_and_registers();
let index = registers.push_register().unwrap();
stack.push(42_i32);
let mut register = registers.access_register(index).unwrap();;
registers.pop_to_register(&amp;mut register);
stack.push_from_register(&amp;mut register);
assert_eq!(stack.pop::&lt;i32&gt;().unwrap(), 42);
<span class="boring">}</span></code></pre></pre>
<p>Please remember that registers just like stack, data can be only moved in and out of registers, registers operations does not copy/clone their data - this design choice was dictated by master rule of Intuicio: &quot;data can only be moved&quot;, copy/clone is a special operation that structure has to provide a dedicated function for it to push duplicated source data into stack, from which original data gets moved back to register and its clone stays on the stack - this is how for example <code>simpleton</code> frontend does when has to copy <code>Reference</code> from local variable.</p>
</li>
<li>
<p><strong>Heap</strong></p>
<p>Used to store dynamically allocated data in case user wants to ensure that data lifetime to be bound to the context (die along with context death). To be honest, this is not widely used piece of context, since data stored in any of the other pieces of context has no requirement to come from context's heap, it works perfectly fine with data allocated purely on rust-side, although at some point there might be a scenario where having boxed data owned by context is beneficial, therefore it is exposed to the user.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut value = context.heap().alloc(0_i32);
*value.write().uwnrap() = 42;
assert_eq!(*value.read().unwrap(), 42);
<span class="boring">}</span></code></pre></pre>
<p>It's worth noting that memory allocated by heap box gets automatically returned to the heap once heap box drops, so there is no explicit heap box deallocation.</p>
</li>
<li>
<p><strong>Custom data</strong></p>
<p>Now this is the interesting bit, it is basically a hash map of <code>Box&lt;Any + Send + Sync&gt;</code> objects that does not fit to any of the other context pieces. It is useful for storing any meta information. For example <code>simpleton</code> frontend stores there its <code>HostProducer</code> that is used to construct new <code>Host</code> for any spawned <code>Jobs</code> worker thread, so each worker thread can execute closures pased into it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>context.set_custom(&quot;foo&quot;, 42_i32);
assert_eq!(*context.custom::&lt;i32&gt;().unwrap(), 42);
<span class="boring">}</span></code></pre></pre>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="scripting-pipeline-explained.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="anatomy-of-a-script.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="scripting-pipeline-explained.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="anatomy-of-a-script.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
